'''PulseUtils module for handling binary code assembly'''
# ----------------------------------------
import re
import io
from pulseutils.logging import Logger
from pulseutils.system import execute_command
# ----------------------------------------
class GenericAsmData:
    '''Base class for representing and accessing assembly code.'''

    def __init__(self, source, data, logger=Logger()):
        '''Initialize the wrapper.

        :param source: source of the binary assembly code data
        :param data: objdump assembly code data
        :type source: str
        :type data: str or fp('r')
        '''
        self.source = source
        self.log = logger
        self.asmdata = { None: {} }
        if isinstance(data, str):
            with io.StringIO(data) as stream:
                self._parse(stream)
        else:
            self._parse(data)

    def has_section(self, section):
        ''':return: True iff there is a section :code:`section` in the assembly code.'''
        return section in self.asmdata

    def as_memory(self, section):
        ''':return: a memory representation (address -> label) of the section :code:`section`.
        :rtype: dict(int, str)
        '''
        return { ldata['loc'] : label for label, ldata in self.asmdata[section].items() }

    def matches_labels_of(self, ofile, section):
        ''':return: True iff the labels of the :code:`section` section are identical in self and :code:`ofile`.
        :type ofile: :class:`GenericAsmData`
        '''
        return self.asmdata[section].keys() == ofile.asmdata[section].keys()

    def get_skip_locs(self, sfile):
        '''Compares the instructions of self and :code:`sfile` and returns the addresses of the skipped ones in self.

        :type sfile: :class:`GenericAsmData`
        :rtype: tuple(int)
        '''
        locs = []
        for label, ldata in sfile.asmdata['.text'].items():
            for loc, sval in ldata['content'].items():
                mval = self.asmdata['.text'][label]['content'][loc]
                if sval != mval and self._is_skip_instruction(mval):
                    locs.append(loc)
        if len(locs) == 0:
            return (-1,)
        return tuple(locs)

    def _instruction_lookup(self, loc):
        if self.has_section('.text'):
            inst = None
            for label, ldata in self.asmdata['.text'].items():
                if loc in ldata['content']:
                    inst = ldata['content'][loc]
                    break
            if inst is not None:
                return inst
            self.log.error('no instruction at loc {} in .text of {}'.format(loc, self.source))
            raise KeyError('{}'.format(loc))
        self.log.error('no .text section in {}: cannot recover instruction at {}'.format(self.source, loc))
        raise KeyError('.text')

    def get_instruction_code(self, loc):
        ''':return: the integer code of the instruction at address :code:`loc`.'''
        inst = self._instruction_lookup(loc)
        matcher = re.match(self._instruction_code_regex_matcher, inst)
        if matcher is not None:
            return int(matcher[0].replace(' ', '').replace('\t', ''), 16)
        return -1

    def get_instruction_bytes(self, loc, bfl=True):
        ''':return: the bytearray of the instruction at address :code:`loc`.'''
        inst = self._instruction_lookup(loc)
        matcher = re.match(self._instruction_code_regex_matcher, inst)
        if matcher is not None:
            mstr = matcher[0]
            mbar = bytearray.fromhex(mstr)
            if bfl:
                bidx = 0
                while bidx + 1 < len(mbar):
                    tmp = mbar[bidx]
                    mbar[bidx] = mbar[bidx+1]
                    mbar[bidx+1] = tmp
                    bidx += 2
            return mbar
        return -1

    def get_instruction(self, loc):
        ''':return: the string representation of the instruction at address :code:`loc`.
        :rtype: opcode:str, operands:str'''
        inst = self._instruction_lookup(loc)
        matcher = re.match(self._instruction_regex_matcher, inst)
        if matcher is not None:
            return matcher[3], matcher[4].split(';')[0].strip()
        return 'UNDEFINED', ''

    def get_instruction_size(self, loc):
        ''':return: the size (bytes) of the instruction at address :code:`loc`.'''
        return self._instruction_size(self._instruction_lookup(loc))

    def has_function(self, name):
        ''':return: True iff there exist a label :code:`name` in the .text section.'''
        return self.has_section('.text') and name in self.asmdata['.text']

    def _core_label_access(self, label, key, section=None):
        if section is not None:
            return self.asmdata[section][label][key]
        for section, sdata in self.asmdata.items():
            if label in sdata:
                return sdata[label][key]
        raise KeyError(label)

    def address_of(self, label, section=None):
        ''':return: the address of the given label, either in the given section or in the first found section.
        .. warning::
            if no section is provided and labels with identical names exist in disctinct section, this
            function is not deterministic.
        '''
        return self._core_label_access(label, 'loc', section)

    def bytesize_of(self, label, section=None):
        ''':return: the size (byte) of the given label, either in the given section or in the first found section.
        .. warning::
            if no section is provided and labels with identical names exist in disctinct section, this
            function is not deterministic.
        '''
        # Look up the label entry once to allow multiple fallbacks without re-searching
        entry = None
        if section is not None and section in self.asmdata and label in self.asmdata[section]:
            entry = self.asmdata[section][label]
        else:
            for psection, sdata in self.asmdata.items():
                if label in sdata:
                    entry = sdata[label]
                    break
        if entry is None:
            raise KeyError(label)

        # Prefer explicit align/size hints; fall back to computing from instructions.
        if 'align' in entry:
            return entry['align']
        if 'size' in entry:
            return entry['size']
        if 'content' in entry:
            try:
                return sum(self._instruction_size(inst) for inst in entry['content'].values())
            except NotImplementedError:
                # If we cannot infer size (e.g., architecture parsing issue), fall back to 0 to keep the pipeline running.
                return 0
        return 0

    def instructions(self, label, section=None, details=False):
        '''Iterates over tuples address, instruction [, type, size] for the given label in the given section.

        Only generates type and size if :code:`details` is True.
        '''
        if section is None:
            for psection, sdata in self.asmdata.items():
                if label in sdata:
                    section = psection
                    break
        for loc, inst in sorted(self.asmdata[section][label]['content'].items(), key=lambda li: li[0]):
            if details:
                yield loc, inst, self._instruction_type(inst), self._instruction_size(inst)
            else:
                yield loc, inst

    def labels(self, section=None, sections=None):
        '''Iterates over the labels of the given section, sections or all available sections.'''
        if section is not None:
            for label in self.asmdata[section]:
                yield label
        elif sections is not None:
            for psection in sections:
                if psection in self.asmdata:
                    for label in self.asmdata[psection]:
                        yield label
        else:
            for psection, sdata in self.asmdata.items():
                for label in sdata:
                    yield label

    def load_symbol_table(self, data):
        '''Load and read contextual data from an objdump symbol table file or stream'''
        if isinstance(data, str):
            with io.StringIO(data) as stream:
                self.read_symbol_table(stream)
        else:
            self.read_symbol_table(data)

    def read_symbol_table(self, stream):
        '''Add contextual data from an objdump symbol table stream'''
        stblrp = r'([0-9a-f]+)[ \t]([lg !])([w ])([C ])([W ])([I ])([dD ])([FfO ])[ \t]([*._a-zA-Z0-9]+)[ \t]+([0-9a-f]+)[ \t]+(.hidden[ \t])?([*._a-zA-Z0-9]+)'
        for line in stream:
            tlmatch = re.match(stblrp, line.strip())
            if tlmatch:
                section = tlmatch[9]
                symbol = tlmatch[12]
                align = int(tlmatch[10], 16)
                memloc = int(tlmatch[1], 16)
                self._update_data(section, symbol, memloc, align=align)

    def _update_data(self, section, symbol, memloc, align=0):
        if not section in self.asmdata:
            self.asmdata[section] = {}
        if not symbol in self.asmdata[section]:
            self.asmdata[section][symbol] = {'loc': memloc, 'align': align, 'content': {}}
        elif not 'align' in self.asmdata[section][symbol]:
            self.asmdata[section][symbol]['align'] = align
# ----------------------------------------
class x86AsmData(GenericAsmData):

    def __init__(self, source, data, logger=Logger()):
        super().__init__(source, data, logger)

        self._instruction_regex_matcher = r'([0-9a-f]{2})([ \t][0-9a-f]{2})*[ \t]+([a-z.]+)[ \t]*(.*)'
        self._instruction_code_regex_matcher = r'([0-9a-f]{2})([ \t][0-9a-f]{2})*'

    def _is_skip_instruction(self, ival):
        raise NotImplementedError(self)

    def _instruction_type(self, ival):
        raise NotImplementedError(self)

    def _instruction_size(self, ival):
        raise NotImplementedError(self)

    def _parse(self, stream):
        section = None
        label = None
        for line in stream:
            smatch = re.match(r'Disassembly of section ([._a-zA-Z0-9]+):', line)
            lmatch = re.match(r'([0-9a-f]+)[ \t]*<([^>]+)>:', line)
            dmatch = re.match(r'[ \t]*([0-9a-f]+):[ \t]*([0-9a-f]{2})', line)
            if smatch:
                section = smatch[1]
                self.asmdata[section] = {}
            if lmatch:
                memloc = int(lmatch[1], 16)
                label = lmatch[2]
                self.asmdata[section][label] = {'loc': memloc, 'content': {}}
            if dmatch:
                ldata = [c.strip() for c in line.strip().split(':')]
                memloc = int(ldata[0], 16)
                self.asmdata[section][label]['content'][memloc] = ldata[1]
# ----------------------------------------
class x86AsmFile(x86AsmData):

    def __init__(self, filename):
        self.asmdata = { None: {} }
        with open(filename, 'r') as stream:
            self._parse(stream)
# ----------------------------------------
class ArmAsmData(GenericAsmData):

    def __init__(self, source, data, logger=Logger()):
        super().__init__(source, data, logger)

        self._instruction_regex_matcher = r'([0-9a-f]{4})([ \t][0-9a-f]{4})?[ \t]+([a-z.]+)[ \t]*(.*)'
        self._instruction_code_regex_matcher = r'([0-9a-f]{4})([ \t][0-9a-f]{4})?'
        self._literal_regex_matcher = r'([0-9a-f]{8})'

    def _is_skip_instruction(self, ival):
        return 'nop' in ival

    def _instruction_type(self, ival):
        imatch = re.match(self._literal_regex_matcher, ival)
        return 'literal' if imatch else 'instruction'

    def _instruction_size(self, ival):
        imatch = re.match(self._instruction_regex_matcher, ival)
        if imatch:
            return 2 if imatch[2] is None else 4
        imatch = re.match(self._literal_regex_matcher, ival)
        if imatch:
            return 4
        return 0

    def literals(self, section='.text', label=None):
        memory = {}
        if label is not None:
            for loc, inst in self.asmdata[section][label]['content'].items():
                lmatch = re.match(self._literal_regex_matcher, inst)
                if lmatch:
                    memory[loc] = int(lmatch[1], 16)
        else:
            for label in self.asmdata[section].keys():
                memory.update(self.literals(section, label))
        return memory

    def ininstr_constants(self, section='.text', label=None):
        constants = set()
        if label is not None:
            for _, inst in self.asmdata[section][label]['content'].items():
                for lmatch in re.finditer(r'#([0-9]+)', inst):
                    lmatch_o = re.match(r'#([0-9]+)\]', inst[lmatch.start():])
                    if not lmatch_o:
                        constants.add(int(lmatch[1], 10))
        else:
            for label in self.asmdata[section].keys():
                constants.update(self.ininstr_constants(section, label))
        return constants

    def _parse(self, stream):
        section = None
        label = None
        for line in stream:
            smatch = re.match(r'Disassembly of section ([._a-zA-Z0-9]+):', line)
            lmatch = re.match(r'([0-9a-f]+)[ \t]*<([^>]+)>:', line)
            dmatch = re.match(r'[ \t]*([0-9a-f]+):[ \t]*([0-9a-f]{4})', line)
            if smatch:
                section = smatch[1]
                self.asmdata[section] = {}
            if lmatch:
                memloc = int(lmatch[1], 16)
                label = lmatch[2]
                self.asmdata[section][label] = {'loc': memloc, 'content': {}}
            if dmatch:
                ldata = [c.strip() for c in line.strip().split(':')]
                memloc = int(ldata[0], 16)
                self.asmdata[section][label]['content'][memloc] = ldata[1]
# ----------------------------------------
class ArmAsmFile(ArmAsmData):

    def __init__(self, filename):
        self.asmdata = { None: {} }
        with open(filename, 'r') as stream:
            self._parse(stream)
# ----------------------------------------
def autogen_asmdata(binary, dataclass, objdump='objdump'):
    '''Automatically generates a :class:`GenericAsmData` for binary.

    Runs objdump (from the :code:`objdump` executable) to obtain assembly details and symbol tables.
    Parses using the given dataclass.
    '''
    rc, _, asmdata, _ = execute_command([objdump, '-D', binary])
    rc, _, symdata, _ = execute_command([objdump, '-t', binary])
    asm = dataclass(binary, asmdata)
    asm.load_symbol_table(symdata)
    return asm
# ----------------------------------------
def autoget_asminst(binary, dataclass, address, objdump='objdump'):
    '''Automatically generates the assembly instruction representation at the given address of the given binary file.'''
    asm = autogen_asmdata(binary, dataclass, objdump)
    return asm.get_instruction(address)
# ----------------------------------------
