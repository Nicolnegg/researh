# -------------------$
import sys
import os
import io
import re
import subprocess
import time
import itertools
from subprocess import Popen, PIPE, STDOUT, TimeoutExpired
from datetime import datetime
import configparser
# --------------------
from . import minibinsec
from .checkers import CheckerResult, AbstractChecker
from pulseutils.files import create_directory
# --------------------
class BinsecLogChunk:

    def __init__(self, bswitch, level, data):
        self.bswitch = bswitch
        self.level = level
        self.data = data
# --------------------
class BinsecLogParser:

    def __init__(self, data, logger, robust=False, translation=None):
        self.logger = logger
        self.robust = robust

        self.translation = translation if translation is not None else dict()

        self.logdata = []
        self.models = []
        self._last_smt = None
        self._last_model = None

        self.status = {
            'goal-unreachable': False,
            'goal-reached': False,
        }

        self._parse(data)

    def _parse(self, data):
        self._load_data_chunks(data)
        self._parse_chunks()

    def _load_data_chunks(self, data):
        with io.StringIO(data) as stream:
            cstart_hook = r'\[(\w+):(\w+)\]'
            logstr = stream.read()

            prev = None
            for cstart in re.finditer(cstart_hook, logstr):
                if prev is not None:
                    data = logstr[prev.end():cstart.start()-1].strip()
                    self.logdata.append(BinsecLogChunk(prev[1], prev[2], data))
                prev = cstart
            if prev is not None:
                data = logstr[prev.end():].strip()
                self.logdata.append(BinsecLogChunk(prev[1], prev[2], data))

            self.logger.debug('loaded {} data chunks'.format(len(self.logdata)))

    def _parse_chunks(self):
        for chunk in self.logdata:
            handler = '_parse_{}_chunk'.format(chunk.bswitch)
            if hasattr(self, handler):
                getattr(self, handler)(chunk)
        self._push_last_model()

    def _push_last_model(self):
        if self._last_model is not None:
            self.models.append(self._last_model)

    def _parse_sse_chunk(self, chunk):
        handler_core = chunk.data.split()[0].lower()
        handler = '_handle_sse_{}'.format(handler_core)
        if hasattr(self, handler):
            getattr(self, handler)(chunk)
        # New BINSEC emits this as an info line when no path reaches the goal.
        if 'Empty path worklist' in chunk.data:
            self.status['goal-unreachable'] = True

    def _parse_fml_chunk(self, chunk):
        if chunk.data.startswith('Will open'):
            self._handle_smt_source(chunk)

    def _handle_smt_source(self, chunk):
        self._last_smt = chunk.data.replace('Will open ', '')
        if not os.path.isfile(self._last_smt):
            self.logger.warning('recovering unlogged smtfile: {}'.format(self._last_smt))

    def _handle_sse_model(self, chunk):
        self._push_last_model()
        hookd = r'Model @ ([0-9a-f]+)'
        mmatch = re.search(hookd, chunk.data)
        vloc = mmatch[1] if mmatch else 'Unlocated Model'
        model = self._parse_model(chunk.data)
        self._last_model = { 'loc': vloc, 'model' : model, 'enum' : None, 'smtlog': self._last_smt }

    def _handle_sse_goal(self, chunk):
        if chunk.data == 'Goal unreachable.':
            self.status['goal-unreachable'] = True

    def _handle_sse_path(self, chunk):
        # New BINSEC reports reachability as: "Path X reached address ..."
        if 'reached address' in chunk.data:
            self.status['goal-reached'] = True
            # No explicit model is printed; keep an empty model placeholder.
            self._push_last_model()
            self._last_model = { 'loc': 'reach', 'model' : {}, 'enum' : None, 'smtlog': self._last_smt }

    def _parse_model(self, model):
        result = dict()
        for modell in model.split('\n'):
            if ':' in modell:
                ldata = [s.strip() for s in modell.split(':')]
                if len(ldata) > 2:
                    self.logger.warning('multi-colon model var (unhandled): {}'.format(modell))
                if ';' in ldata[1] and not '(;)' in ldata[1]:
                    # parse registers
                    rname = ldata[0]
                    if rname.startswith('bs_unknown1_for_'):
                        rname = rname.replace('bs_unknown1_for_', '')
                        while rname.startswith('_'):
                            rname = rname[1:]
                    if rname.startswith('undef_AF_1___'):
                        rname = rname.replace('undef_AF_1___', '0x')
                    if '_' in rname:
                        rname = rname.split('_')[0]
                    rcontent = ldata[1].replace('{', '').replace('}', '').split(';')
                    rvalue, rsize = rcontent[0].strip(), rcontent[1].strip()
                    if not rname.startswith('dummy') and not rname.startswith('bs'):
                        result[rname] = rvalue
                    # TODO : store and use rsize?
                    #self.logger.debug('from ["{}"]: @[{}] <- {}'.format(modell, rname, rvalue))
                else:
                    # remove ASCII char resolving trailing data
                    #self.logger.debug('from ["{}"]: @[{}] <- {}'.format(modell, ldata[0], ldata[1].split()[0].strip()))
                    k = ldata[0]
                    v = ldata[1].split()[0].strip()
                    # New BINSEC prints concrete memory bytes as "#xADDR: 00".
                    # Normalize to minibinsec's expected memory-variable and
                    # literal formats so generated assumes are valid SSE.
                    if re.match(r'^#x[0-9a-fA-F]+$', k):
                        k = '0x' + k[2:]
                    if re.match(r'^[0-9a-fA-F]+$', v) and not v.startswith(('0x', '0b')):
                        v = '0x' + v
                    result[k] = v
        self.logger.debug('model recovered: {}'.format(result))
        for tvar in set(self.translation.keys()) & set(result.keys()):
            result[self.translation[tvar]] = result[tvar]
            result.pop(tvar)
        return result
# --------------------
def execute_command(cmd, log, timeout=None, stdin=None):
    if stdin is not None:
        stdin = stdin.encode('utf-8')
    log.debug('running: {}'.format(' '.join(cmd)))
    proc = Popen(cmd, stdout=PIPE, stderr=STDOUT, stdin=(PIPE if stdin is not None else None))
    to_status = False
    try:
        cout, cerr = proc.communicate(timeout=timeout, input=stdin)
    except TimeoutExpired:
        to_status = True
        proc.kill()
        cout, cerr = proc.communicate()
    return proc.returncode, to_status, cout.decode(sys.stdout.encoding, errors='ignore'), cerr.decode(sys.stderr.encoding, errors='ignore') if cerr is not None else None
# --------------------
class BinsecAutoCandidateGenerator:

    def __init__(self, args, checkers, stats, logger):
        self.args = args
        self.vars = set()
        self.controlled = set()
        self.operators = set()
        self.checkers = checkers
        self.stats = stats
        self.log = logger
        self.exset = None
        self.cexset = None
        self.ncoreset = None
        self.restart = False
        self._rvars = set()
        self._init_vars()
        self._init_varengine()

    def _init_varengine(self):
        self.checkers.var_engine = self

    def get_controlled(self):
        return { v for v in self.controlled }

    def get_uncontrolled(self):
        return { v for v in self.vars if self.checkers.context.get_type(v) != minibinsec.BVarType.Literal } - self.get_controlled()

    def set_ex_set(self, exset):
        self.exset = exset

    def set_cex_set(self, cexset):
        self.cexset = cexset

    def set_ncore_set(self, ncset):
        self.ncoreset = ncset

    def is_significant(self, elem):
        return True # TODO Check if this returned result is correct

    def _init_vars(self):
        with open(self.args.literals, 'r') as stream:
            for line in stream:
                if line.startswith('constant:'):
                    cvalue = line.strip().split(':')[1]
                    if cvalue.startswith('0b') or cvalue.startswith('0x'):
                        hexvalue = cvalue
                    else:
                        value = int(cvalue)
                        hexvalue = '0x{:x}'.format(value)
                    vid = self.checkers.context.declare_const(hexvalue)
                    self._rvars.add(vid)
                    self.vars.add(vid)
                if line.startswith('variable:'):
                    value = ':'.join(line.strip().split(':')[1:])
                    vid = self.checkers.context.declare_var(value)
                    self._rvars.add(vid)
                    self.vars.add(vid) # TODO: Might be useful to remove this when non-robust version is run
                if self.args.binsec_robust and line.startswith('controlled:'):
                    value = ':'.join(line.strip().split(':')[1:])
                    vid = self.checkers.context.declare_var(value)
                    self.controlled.add(vid)
        if self.args.with_auto_constants:
            # Use byte-sized constants so BINSEC can infer sizes when comparing
            # against memory bytes (avoid expressions like "0x0::0x1").
            vid = self.checkers.context.declare_const('0x00')
            self.vars.add(vid)
            vid = self.checkers.context.declare_const('0x01')
            self.vars.add(vid)

    def _update_vars(self):
        if self.args.input_variables_only:
            self.vars = self._rvars
            return
        for modelset in (self.exset, self.cexset):
            for model in modelset:
                for key, val in model.items():
                    if not key in { 'default', '*controlled' }:
                    #if (key.startswith('0x') or
                    #    (key != 'default' and int(val, 16) != 0)):
                        # Commented version looks for non null registers only
                        if not self.checkers.fully_assumed(key):
                            self.checkers.context.declare_var(key)
                            self.vars.add(key)

    def _update_operators(self):
        # TODO : Use a config file instead
        self.operators.add(minibinsec.Operator.Equal)
        if self.args.with_disequalities:
            self.operators.add(minibinsec.Operator.Distinct)
        if self.args.with_inequalities:
            self.operators.add(minibinsec.Operator.Lower)

    def _reduce_auto(self, varset):
        # In robust mode, allow controlled vars in literal generation; otherwise
        # we can end up with no relational literals for abduction.
        if self.args.binsec_robust:
            return set(varset)
        return { v for v in varset if not v in self.controlled }

    def _generate_literals(self):
        lits = []
        for op in self.operators:
            if op != minibinsec.Operator.Lower:
                for var1, var2 in itertools.combinations(self._reduce_auto(self.vars), 2):
                    if self.checkers.context.is_const(var1) and self.checkers.context.is_const(var2):
                        continue
                    if self.args.no_variables_binop and (not self.checkers.context.is_const(var1)) and (not self.checkers.context.is_const(var2)):
                        continue
                    if self.args.core_literals:
                        literal = self.checkers.context.create_binary_term(op, var1, var2)
                        if not literal in self.ncoreset:
                            lits.append(literal)
                    if self.args.separate_bytes:
                        lits.extend(self._generate_byte_literals(op, var1, var2))
                    if self.args.separate_bits:
                        lits.extend(self._generate_bit_literals(op, var1, var2))
            else:
                for var1, var2 in itertools.permutations(self._reduce_auto(self.vars), 2):
                    if self.checkers.context.is_const(var1) and self.checkers.context.is_const(var2):
                        continue
                    if self.args.no_variables_binop and (not self.checkers.context.is_const(var1)) and (not self.checkers.context.is_const(var2)):
                        continue
                    if self.args.core_literals:
                        literal = self.checkers.context.create_binary_term(op, var1, var2)
                        if not literal in self.ncoreset:
                            lits.append(literal)
                    # TODO: byte and bit separation for inequalities
        return lits

    def _generate_byte_literals(self, op, var1, var2):
        lits = []
        var1s, var2s = self.checkers.context.get_size(var1), self.checkers.context.get_size(var2)
        var1t, var2t = self.checkers.context.get_type(var1), self.checkers.context.get_type(var2)
        if var1s != var2s:
            var1bytes = self.checkers.context.create_bytes(var1) if var1s > 8 and var1t != minibinsec.BVarType.Literal else []
            var2bytes = self.checkers.context.create_bytes(var2) if var2s > 8 and var2t != minibinsec.BVarType.Literal else []
            if len(var1bytes) == 0 and len(var2bytes) != 0:
                var1bytes = [var1]
            if len(var1bytes) != 0 and len(var2bytes) == 0:
                var2bytes = [var2]
            for var1byte in var1bytes:
                for var2byte in var2bytes:
                    literal = self.checkers.context.create_binary_term(op, var1byte, var2byte)
                    if not literal in self.ncoreset:
                        lits.append(literal)
        return lits

    def _generate_bit_literals(self, op, var1, var2):
        lits = []
        var1s, var2s = self.checkers.context.get_size(var1), self.checkers.context.get_size(var2)
        var1t, var2t = self.checkers.context.get_type(var1), self.checkers.context.get_type(var2)
        if var1s != var2s:
            var1bits = self.checkers.context.create_bits(var1) if var1t != minibinsec.BVarType.Literal else []
            var2bits = self.checkers.context.create_bits(var2) if var2t != minibinsec.BVarType.Literal else []
            if len(var1bits) == 0 and len(var2bits) != 0:
                var1bits = [var1]
            if len(var1bits) != 0 and len(var2bits) == 0:
                var2bits = [var2]
            for var1bit in var1bits:
                for var2bit in var2bits:
                    literal = self.checkers.context.create_binary_term(op, var1bit, var2bit)
                    if not literal in self.ncoreset:
                        lits.append(literal)
        return lits

    def restart_local_generation(self):
        self.restart = True

    def generate(self):
        old_length = 0
        self.restart = False
        self._update_vars()
        # Initial try with no constraint
        yield set()
        lits = []
        while True:
            self._update_vars()
            self.log.debug(f'loaded variables: {self.vars}')
            new_length = len(self.vars)
            self.stats.generation.restart += 1
            self.stats.generation.vars = new_length
            if not self.restart and new_length == old_length:
                break
            if self.restart:
                self.log.debug('externally triggered restart')
                self.restart = False
            self.log.info('restart vars->literal generation')
            old_length = new_length
            self._update_operators()
            lits = self._generate_literals()
            self.stats.generation.literals = len(lits)
            if self.args.lit_ordering:
                mtable = { lit : (-sum(self.checkers.check_satisfied({lit}, model)[0] for model in self.exset), lit.complexity()) for lit in lits }
                self.log.debug('literals ordering table: {}'.format(mtable))
                lits.sort(key=lambda lit: mtable[lit])
            self.log.debug('literals list: {}'.format(lits))
            for depth in range(2):
                # Initial max2 to redetect variables on necessary checks
                # TODO: This exploration algorithm must be reworked
                for candidate in itertools.combinations(lits, depth):
                    yield set(c for c in candidate)
                if self.restart:
                    break
            if self.restart:
                break
        if len(lits) == 0:
            return
        rangeout = self.args.max_depth + 1 if self.args.max_depth is not None else len(lits) + 1
        for depth in range(2, rangeout):
            for candidate in itertools.combinations(lits, depth):
                yield set(c for c in candidate)
# --------------------
class BinsecCheckers(AbstractChecker):

    Temporary_Binsec_Configfile = 'temp.binsec.{}.sse'

    def __init__(self, args, stats, logger):
        super().__init__(args, stats, logger)
        self.config = self._load_config()
        self.directives = self._load_directives()
        self.binary = self.args.binsec_binary
        self.addr = self.args.binsec_addr
        self.configdir = self.args.binsec_config_logdir
        create_directory(self.configdir)
        self.context = minibinsec.Context(self.log)
        self.var_engine = None

    def _load_config(self):
        # Base config is meant to describe the initial state (stack, memory,
        # stubs, etc.). Goals (reach/cut/at assume) must be controlled by the
        # directives file, otherwise we end up with *multiple* reach goals in
        # the generated temp scripts, which confuses both BINSEC and PyAbduce.
        #
        # This matches the "new BINSEC" scripts we use elsewhere in the repo.
        base_lines = []
        with open(self.args.binsec_config, 'r') as stream:
            for line in stream:
                l = line.strip()
                if not l:
                    base_lines.append("")
                    continue
                # Drop any goal-related directives from the base template.
                if l.startswith(("reach ", "cut ", "at ")):
                    continue
                # Also drop legacy "0xADDR reach/cut" forms if present.
                if re.match(r"^0x[0-9a-fA-F]+\s+(reach|cut)\b", l):
                    continue
                base_lines.append(line.rstrip("\n"))
        base = "\n".join(base_lines).rstrip() + "\n"
        mem = ''
        if self.args.binsec_memory:
            try:
                with open(self.args.binsec_memory, 'r') as stream:
                    mem = stream.read()
            except FileNotFoundError:
                mem = ''
        if mem:
            if not base.endswith('\n'):
                base += '\n'
            base += mem
        return base

    def _load_directives(self):
        with open(self.args.binsec_directives, 'r') as stream:
            result = []
            result_u = []
            result_r = []
            for line in stream:
                ldata = line.strip()
                if ldata.startswith('+'):
                    result_r.append(ldata[1:].strip())
                elif ldata.startswith('-'):
                    result_u.append(ldata[1:].strip())
                else:
                    result.append(ldata)
            directives = { 'all': result, 'negative': result_u, 'positive': result_r }
            self.log.debug('loaded binsec directives: {}'.format(directives))
            return directives

    def _get_local_cfname(self):
        timestamp = datetime.now().strftime('%Y-%m-%d.%H-%M-%S.%f')
        filename = self.Temporary_Binsec_Configfile.format(timestamp)
        return os.path.join(self.configdir, filename)

    def _format_solution_set(self, solutions):
        return ('!({})'.format(' & '.join(['({})'.format(c) for c in s]) ) for s in solutions if len(s) > 0)
        #return '!({})'.format('|'.join(['({})'.format(' & '.join(['({})'.format(c) for c in s])) for s in solutions]))

    def fully_assumed(self, addr):
        for directive in self.directives['all']:
            if 'assume' in directive:
                # TODO: Unsafe, many cases not handled
                if addr in directive and ' = ' in directive:
                    return True

    def check_goals(self, candidate):
        '''True when forall neg -> unreachable but exists not neg -> reachable'''
        status, model, gcore = self._check_ngoal_unreachable(candidate)
        statusr, modelr, rcore = True, None, None
        if status:
            self.stats.get_oracle('binsec-unsat-consistent').calls += 1
            statusr, modelr, rcore = self._check_dgoal_reachable(candidate)
        return status, statusr, model, modelr, gcore, rcore

    def check_necessity(self, solutions):
        self.log.debug('necessary condition check')
        if not solutions:
            # No solutions to check -> consider necessary by default, avoid empty assume.
            return True
        directives = [ d for d in self.directives['all'] ]
        directives.extend(self.directives['positive'])
        constraint = self._format_solution_set(solutions)
        parser = self._run_binsec_command(constraint, directives, formatted=False)
        status = len(parser.models) == 0
        return status

    def check_vulnerability(self, candidate, reject, complete=False):
        self.log.debug('vulnerability check')
        return self._check_dgoal_reachable_util(candidate, reject, complete)

    @staticmethod
    def _pick_model(parser):
        # With "new BINSEC", logs often contain:
        #   [sse:result] Path X reached address ...
        # before the actual "Model ..." lines. The current parser stores an
        # empty placeholder model for the "Path reached" line, so models[0]
        # can be {} even when a real model is present later.
        if not getattr(parser, 'models', None):
            return None
        for m in parser.models:
            mm = m.get('model')
            if mm:
                return mm
        return parser.models[-1].get('model')

    def _check_dgoal_reachable_util(self, candidate, reject, complete=False):
        directives = [ d for d in self.directives['all'] ]
        directives.extend(self.directives['positive'])
        for example in reject:
            directive_op = minibinsec.Operator.And if complete else minibinsec.Operator.Or
            rdir = self._generate_rejection_directive(example, op=directive_op)
            if rdir:
                directives.append(rdir)
        parser = self._run_binsec_command(candidate, directives)
        status = len(parser.models) > 0
        model = self._pick_model(parser)
        return status, model, None

    def _check_dgoal_reachable(self, candidate):
        return self._check_dgoal_reachable_util(candidate, [])

    def _check_ngoal_unreachable(self, candidate):
        directives = [ d for d in self.directives['all'] ]
        directives.extend(self.directives['negative'])
        parser = self._run_binsec_command(candidate, directives)
        status = parser.status['goal-unreachable']
        model = self._pick_model(parser)
        if not status and model is None:
            self.log.warning('binsec test returned neither model nor unreachable')
            # TODO: Handle unknown case (such as timeouts)
        return status, model, None

    def negate(self, candidate):
        ncandidate = { self.context.create_negation(candidate) }
        return ncandidate

    def as_literal(self, model, coreop=minibinsec.Operator.Equal, op=minibinsec.Operator.And):
        data = []
        for key, val in model.items():
            if key != 'default':
                data.append(self.context.create_var_assignment(coreop, key, val))
        return data[0] if len(data) == 1 else self.context.create_multiterm(op, data)

    def _generate_rejection_directive(self, model, op=minibinsec.Operator.Or):
        if model is None:
            return None
        alit = self.as_literal(model, coreop=minibinsec.Operator.Distinct, op=op)
        if not alit:
            return None
        return 'at {} assume {}'.format(self.addr, alit)

    def _normalize_directive(self, directive):
        dstr = directive.strip()
        if not dstr:
            return None
        # Drop empty assume directives (invalid in new BINSEC SSE).
        if re.match(r'^at\\s+0x[0-9a-fA-F]+\\s+assume\\s*$', dstr):
            return None
        parts = dstr.split()
        if len(parts) == 3 and parts[0] == 'at' and parts[2] == 'assume' and parts[1].startswith('0x'):
            return None
        # Accept already-normalized SSE script syntax.
        if dstr.startswith(('starting from', 'reach ', 'cut ', 'at ')):
            # Ensure reach directives emit a model unless explicitly overridden.
            if dstr.startswith('reach ') and 'then print' not in dstr:
                return dstr + ' then print model'
            return dstr
        parts = dstr.split()
        if len(parts) >= 2 and parts[0].startswith('0x'):
            if parts[1] == 'reach':
                dstr = 'reach {}'.format(parts[0])
                if 'then print' not in dstr:
                    dstr += ' then print model'
                return dstr
            if parts[1] == 'cut':
                return 'cut at {}'.format(parts[0])
        return dstr

    def _build_script_from_base(self, base, directives):
        lines = []
        base = base.strip()
        if base:
            lines.append(base)
        for directive in directives:
            ndir = self._normalize_directive(directive)
            if ndir:
                lines.append(ndir)
        return '\n'.join(lines) + '\n'

    def _build_script(self, directives):
        return self._build_script_from_base(self.config, directives)

    def _run_binsec_command(self, candidate, directives, formatted=False):
        self.stats.get_oracle('binsec').calls += 1
        if formatted:
            if candidate:
                cstr = str(candidate).strip()
                if cstr:
                    directives.append('at {} assume {}'.format(self.addr, cstr))
        else:
            for assump in candidate:
                if assump:
                    astr = str(assump).strip()
                    if astr:
                        directives.append('at {} assume {}'.format(self.addr, astr))
        local_config_file = self._get_local_cfname()
        with open(local_config_file, 'w') as stream:
            stream.write(self._build_script(directives))
        command = ['binsec', '-sse', '-sse-script', local_config_file, self.binary]
        btime = time.time()
        rc, to, out, err = execute_command(command, self.log, timeout=self.args.binsec_timeout)
        atime = time.time()
        if to:
            self.log.warning('command timeouted')
            self.stats.get_oracle('binsec').timeouts += 1
        elif rc != 0:
            self.log.warning('command failed')
            self.stats.get_oracle('binsec').crashes += 1
            # Keep failing script and dump output for debugging.
            try:
                log_path = local_config_file + '.log'
                with open(log_path, 'w') as lstr:
                    lstr.write(out)
                    if err:
                        lstr.write('\n--- stderr ---\n')
                        lstr.write(err)
                self.log.warning('binsec failure log saved to {}'.format(log_path))
            except Exception as exc:
                self.log.warning('could not write binsec failure log: {}'.format(exc))
        else:
            self.stats.get_oracle('binsec').times.append(atime - btime)
        parser = BinsecLogParser(out, self.log)
        if self.args.binsec_delete_configs and rc == 0 and not to:
            os.remove(local_config_file)
        return parser

    def check_consistency(self, candidate):
        self.stats.get_oracle('minibinsec').calls += 1
        return minibinsec.check_sat(candidate, self.context), None, None

    def check_satisfied(self, candidate, model):
        self.stats.get_oracle('minibinsec').calls += 1
        return minibinsec.check_sat_model(candidate, model, self.context), None, None

    def _precheck_consequence(self, implicant, implicate):
        '''only works for conjunctions'''
        return implicate.issubset(implicant)

    def check_consequence(self, implicant, implicate, mode_override=None):
        if self._precheck_consequence(implicant, implicate):
            return True, None, None
        if mode_override == 'exact' or self.args.consequence_checks_mode == 'exact':
            self.stats.get_oracle('minibinsec').calls += 1
            return minibinsec.check_consequence(implicant, implicate, self.context), None, None
        return False, None, None
# --------------------
class BinsecMemory:

    def __init__(self, context):
        self.context = context
        self.rules = []
        self.controlled = {}

    @property
    def translator(self):
        return { dvar.split('<')[0] : self.expandtl(dval) for dvar, dval in self.controlled.items() }

    def expandtl(self, val):
        return val.core

    def add_rule(self, rule):
        self.rules.append(rule)

    def set_controlled(self, controlled):
        varid = 0
        self.controlled.clear()
        for control in controlled:
            dvar = 'dvar{}<{}>'.format(varid, self.context.get_size(control))
            varid += 1
            self.controlled[dvar] = self.context.vars[control][0]

    def write(self, stream):
        for control, real in self.controlled.items():
            # BINSEC SSE (new) does not accept the old "controlled" directive.
            # Use explicit nondet assignment for controlled vars instead.
            stream.write('{} := nondet\n'.format(control))
            # Avoid semicolons and type suffixes on RHS for SSE parser compatibility.
            base = control.split('<', 1)[0]
            stream.write('{} := {}\n'.format(real, base))
        for rule in self.rules:
            stream.write(rule)
            stream.write('\n')
# --------------------
class RobustBinsecCheckers(BinsecCheckers):

    def __init__(self, args, stats, logger):
        super().__init__(args, stats, logger)
        self.memory = self._load_memory()
        self.robust_config = self._load_robust_config()

    def _load_robust_config(self):
        with open(self.args.robust_config, 'r') as stream:
            return stream.read()

    def _load_memory(self):
        memory = BinsecMemory(self.context)
        with open(self.args.binsec_memory, 'r') as stream:
            for line in stream:
                memory.add_rule(line.strip())
        return memory

    def check_goals(self, candidate):
        '''True when forall neg -> unreachable but exists not neg -> reachable'''
        status, model, gcore = self._check_ngoal_unreachable(candidate)
        statusr, modelr, rcore = True, None, None
        if status:
            self.stats.get_oracle('binsec-unsat-consistent').calls += 1
            statusr, modelr, rcore = self._check_dgoal_reachable(candidate)
            if statusr:
                status, modelf, fcore = self._check_dgoal_robust(candidate)
        return status, statusr, model, modelr, gcore, rcore

    def _run_binsec_robust_command(self, candidate, directives, controlled, formatted=False):
        self.stats.get_oracle('binsec').calls += 1
        if formatted:
            if candidate:
                cstr = str(candidate).strip()
                if cstr:
                    directives.append('at {} assume {}'.format(self.addr, cstr))
        else:
            for assump in candidate:
                if assump:
                    astr = str(assump).strip()
                    if astr:
                        directives.append('at {} assume {}'.format(self.addr, astr))
        local_config_file = self._get_local_cfname()
        self.memory.set_controlled(controlled)
        mem_buf = io.StringIO()
        self.memory.write(mem_buf)
        script = self._build_script_from_base(self.robust_config, directives)
        mem_rules = mem_buf.getvalue()
        if mem_rules:
            script = script.rstrip() + '\n' + mem_rules
        with open(local_config_file, 'w') as stream:
            stream.write(script)
        command = ['binsec', '-sse', '-sse-script', local_config_file, self.binary]
        btime = time.time()
        rc, to, out, err = execute_command(command, self.log, timeout=self.args.binsec_timeout)
        atime = time.time()
        if to:
            self.log.warning('command timeouted')
            self.stats.get_oracle('binsec').timeouts += 1
        elif rc != 0:
            self.log.warning('command failed')
            self.stats.get_oracle('binsec').crashes += 1
        else:
            self.stats.get_oracle('binsec').times.append(atime - btime)
        parser = BinsecLogParser(out, self.log, robust=True, translation=self.memory.translator)
        if self.args.binsec_delete_configs:
            os.remove(local_config_file)
        return parser

    def _check_ngoal_unreachable(self, candidate):
        directives = [ d for d in self.directives['all'] ]
        directives.extend(self.directives['negative'])
        # Use controlled variables for robust exploration; uncontrolled vars should not
        # be treated as controllable inputs in the memory overlay.
        parser = self._run_binsec_robust_command(candidate, directives, self.var_engine.get_controlled())
        status = parser.status['goal-unreachable'] or len(parser.models) <= 0
        model = self._pick_model(parser)
        if not parser.status['goal-unreachable'] and model is None:
            self.log.warning('binsec test returned neither model nor unreachable')
            # TODO: Handle unknown case (such as timeouts)
        if model is not None:
            model['*controlled'] = self.var_engine.get_controlled()
        return status, model, None

    def _check_dgoal_robust(self, candidate):
        directives = [ d for d in self.directives['all'] ]
        directives.extend(self.directives['positive'])
        parser = self._run_binsec_robust_command(candidate, directives, self.var_engine.get_controlled())
        status = len(parser.models) > 0
        return status, None, None
# --------------------
