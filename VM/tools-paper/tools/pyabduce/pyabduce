#!/usr/bin/env python3
# ----------------------------------------
import sys
import argparse
import traceback
import signal
from argparse import ArgumentParser
from pulseutils.logging import Logger
from pyabduction import AbductionSolver, Stats, SimpleCandidateEngine, SimpleCandidateGenerator, ConsequenceCheckModes
from pyabduction.binsec import BinsecCheckers, BinsecAutoCandidateGenerator, RobustBinsecCheckers
# ----------------------------------------
class TopLevelTermination(Exception):
    pass
# ----------------------------------------
def termination_handler(signum, sigframe):
    raise TopLevelTermination()
# ----------------------------------------
def main(args):
    logger = Logger(level=4 if args.debug else 3, color=args.log_color, log_progress=args.log_progress)
    try:
        stats = Stats()
        signal.signal(signal.SIGTERM, termination_handler)
        checkers = RobustBinsecCheckers(args, stats, logger) if args.binsec_robust else BinsecCheckers(args, stats, logger)
        #generator = SimpleCandidateGenerator(args, args.literals, stats, logger)
        generator = BinsecAutoCandidateGenerator(args, checkers, stats, logger)
        engine = SimpleCandidateEngine(args, checkers, generator, stats, logger)
        solver = AbductionSolver(args, engine, checkers, stats, logger)
        solver.solve()
        if args.log_stats:
            stats.log(logger)
    except TopLevelTermination as e:
        if args.log_stats:
            stats.log(logger)
        logger.fatal('top-level termination')
        sys.exit(1)
    except Exception as e:
        if args.log_stats:
            stats.log(logger)
        tbs = traceback.format_exc()
        logger.fatal('top-level exception recovery')
        for line in tbs.split('\n'):
            if line:
                logger.error(line)
        sys.exit(1)
    except KeyboardInterrupt as e:
        if args.log_stats:
            stats.log(logger)
        tbs = traceback.format_exc()
        logger.fatal('keyboard interruption recovery')
        for line in tbs.split('\n'):
            if line:
                logger.error(line)
        sys.exit(1)
# ----------------------------------------
if __name__ == '__main__':
    ap = ArgumentParser(description='Abduction Solver')

    gg = ap.add_argument_group('I/Os options')
    gg.add_argument('-d', '--debug', action='store_true', help='print debug messages')
    gg.add_argument('--no-color', action='store_false', dest='log_color', help='no colors in log')
    gg.add_argument('--no-progress', action='store_false', dest='log_progress', help='no progress in log')
    gg.add_argument('--no-stats', action='store_false', dest='log_stats', help='no statistics in log')

    bg = ap.add_argument_group('Binsec options')
    bg.add_argument('--binsec-config', action='store', metavar='<binsec.conf>', help='binsec core configuration')
    bg.add_argument('--binsec-memory', action='store', metavar='<binsec.mem>', help='binsec core memory')
    bg.add_argument('--binsec-directives', action='store', metavar='<directives>', help='initial binsec directives')
    bg.add_argument('--binsec-binary', action='store', metavar='<binary>', help='binary file for binsec')
    bg.add_argument('--binsec-addr', action='store', metavar='<addr>', help='address of additional directives')
    bg.add_argument('--binsec-model-via-smt', action='store_true', help='use external smt solver to check model satisfaction')
    bg.add_argument('--binsec-config-logdir', action='store', metavar='<directory>', default='.binsec-config',
                    help='directory for logging binsec configurations')
    bg.add_argument('--binsec-delete-configs', action='store_true', help='delete local binsec configs')
    bg.add_argument('--binsec-timeout', action='store', metavar='<seconds>', type=int, default=30, help='timeout for binsec calls')
    bg.add_argument('--solver-timeout', action='store', metavar='<seconds>', type=int, default=15, help='timeout for solver calls')
    bg.add_argument('--binsec-robust', action='store_true', help='use variable control from robustness')
    bg.add_argument('--robust-config', action='store', metavar='<robust.conf>', help='binsec robustness core configuration')

    cg = ap.add_argument_group('Candidate generation options')
    cg.add_argument('--literals', action='store', metavar='<grammar>', help='candidates generation rules')
    cg.add_argument('--max-depth', action='store', metavar='<int>', type=int, help='max number of conjunctive literals')
    cg.add_argument('--sat-via-smt', action='store_true', help='use external smt solver to check consistency satisfaction')
    cg.add_argument('--consequence-checks-mode', action='store', metavar='<mode>', choices=ConsequenceCheckModes, default=ConsequenceCheckModes[0],
                    help='algorithmic mode to use for checking logical consequence status between candidates (available modes: {})'.format(', '.join(ConsequenceCheckModes)))
    cg.add_argument('--vexamples-init-count', action='store', metavar='<int>', type=int, default=0, help='number of initial vulnerability examples to recover')
    cg.add_argument('--no-constant-detection', action='store_false', dest='const_detect', help='do not predetect necessary constant equalities')
    cg.add_argument('--no-core-literals', action='store_false', dest='core_literals', help='do not add literals that do not contain any separated variable')
    cg.add_argument('--separate-bytes', action='store_true', help='separate variables in bytes')
    cg.add_argument('--separate-bits', action='store_true', help='separate variables in bits')
    cg.add_argument('--with-inequalities', action='store_true', help='use lt operator in litgen')
    cg.add_argument('--without-disequalities', action='store_false', dest='with_disequalities', help='do not use distinct operator in litgen')
    cg.add_argument('--with-auto-constants', action='store_true', help='add default basic constants 0, 1 to varset')
    cg.add_argument('--no-variables-binop', action='store_true', help='never apply binary operators to variable pairs')
    cg.add_argument('--input-variables-only', action='store_true', help='only use the user-given input variables')
    cg.add_argument('--no-literal-ordering', action='store_false', dest='lit_ordering', help='do not reorder literals via heuristic')
    cg.add_argument('--no-prune-counterex', action='store_false', dest='prune_counterex', help='do not prune with counter-examples')
    cg.add_argument('--no-prune-necessary', action='store_false', dest='prune_necessary', help='do not prune with necessary constraints')
    cg.add_argument('--force-on-model-resorting', action='store_true', help='resort literals after each new found example model')

    args = ap.parse_args()

    try:
        main(args)
    except Exception as e:
        raise e
        sys.exit(1)
    sys.exit(0)
# ----------------------------------------
