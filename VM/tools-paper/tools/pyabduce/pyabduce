#!/usr/bin/env python3
# ----------------------------------------
import sys
import os
import json
import argparse
import traceback
import signal
from argparse import ArgumentParser
from pulseutils.logging import Logger
from pyabduction import AbductionSolver, Stats, SimpleCandidateEngine, SimpleCandidateGenerator, ConsequenceCheckModes
from pyabduction.binsec import BinsecCheckers, BinsecAutoCandidateGenerator, RobustBinsecCheckers
# ----------------------------------------
class TopLevelTermination(Exception):
    pass
# ----------------------------------------
def termination_handler(signum, sigframe):
    raise TopLevelTermination()
# ----------------------------------------
def main(args):
    logger = Logger(level=4 if args.debug else 3, color=args.log_color, log_progress=args.log_progress)
    try:
        if args.paper_mode:
            if args.collect_until_timeout:
                logger.warning('--paper-mode: disabling --collect-until-timeout (no early cutoff)')
            args.collect_until_timeout = False
            args.solver_timeout = None
        seed = os.environ.get('PYTHONHASHSEED')
        if seed is None:
            logger.warning('PYTHONHASHSEED is not set (recommended: 0 for reproducible runs)')
        elif seed != '0':
            logger.warning('PYTHONHASHSEED={} (recommended: 0 for reproducible runs)'.format(seed))

        stats = Stats()
        signal.signal(signal.SIGTERM, termination_handler)
        if args.ct_mode and args.binsec_robust:
            raise ValueError('--ct-mode is currently incompatible with --binsec-robust')
        checkers = RobustBinsecCheckers(args, stats, logger) if args.binsec_robust else BinsecCheckers(args, stats, logger)
        #generator = SimpleCandidateGenerator(args, args.literals, stats, logger)
        generator = BinsecAutoCandidateGenerator(args, checkers, stats, logger)
        engine = SimpleCandidateEngine(args, checkers, generator, stats, logger)
        solver = AbductionSolver(args, engine, checkers, stats, logger)
        summary = solver.solve()
        summary['run_profile'] = {
            'paper_mode': bool(args.paper_mode),
            'collect_until_timeout': bool(args.collect_until_timeout),
            'solver_timeout': args.solver_timeout,
            'selection_mode': args.selection_mode,
            'pythonhashseed': os.environ.get('PYTHONHASHSEED'),
            'binsec_env': os.environ.get('BINSEC', 'binsec'),
            'host': os.uname().nodename,
        }
        if args.policy_report:
            rpath = os.path.abspath(args.policy_report)
            rdir = os.path.dirname(rpath)
            if rdir:
                os.makedirs(rdir, exist_ok=True)
            with open(rpath, 'w') as rstream:
                json.dump(summary, rstream, indent=2, sort_keys=True)
            logger.result('policy report written: {}'.format(rpath))
        if args.log_stats:
            stats.log(logger)
    except TopLevelTermination as e:
        if args.log_stats:
            stats.log(logger)
        logger.fatal('top-level termination')
        sys.exit(1)
    except Exception as e:
        if args.log_stats:
            stats.log(logger)
        tbs = traceback.format_exc()
        logger.fatal('top-level exception recovery')
        for line in tbs.split('\n'):
            if line:
                logger.error(line)
        sys.exit(1)
    except KeyboardInterrupt as e:
        if args.log_stats:
            stats.log(logger)
        tbs = traceback.format_exc()
        logger.fatal('keyboard interruption recovery')
        for line in tbs.split('\n'):
            if line:
                logger.error(line)
        sys.exit(1)
# ----------------------------------------
if __name__ == '__main__':
    ap = ArgumentParser(description='Abduction Solver')

    gg = ap.add_argument_group('I/Os options')
    gg.add_argument('-d', '--debug', action='store_true', help='print debug messages')
    gg.add_argument('--no-color', action='store_false', dest='log_color', help='no colors in log')
    gg.add_argument('--no-progress', action='store_false', dest='log_progress', help='no progress in log')
    gg.add_argument('--no-stats', action='store_false', dest='log_stats', help='no statistics in log')

    bg = ap.add_argument_group('Binsec options')
    bg.add_argument('--binsec-config', action='store', metavar='<binsec.conf>', help='binsec core configuration')
    bg.add_argument('--binsec-memory', action='store', metavar='<binsec.mem>', help='binsec core memory')
    bg.add_argument('--binsec-directives', action='store', metavar='<directives>', help='initial binsec directives')
    bg.add_argument('--binsec-binary', action='store', metavar='<binary>', help='binary file for binsec')
    bg.add_argument('--binsec-addr', action='store', metavar='<addr>', help='address of additional directives')
    bg.add_argument('--binsec-model-via-smt', action='store_true', help='use external smt solver to check model satisfaction')
    bg.add_argument('--binsec-config-logdir', action='store', metavar='<directory>', default='.binsec-config',
                    help='directory for logging binsec configurations')
    bg.add_argument('--binsec-delete-configs', action='store_true', help='delete local binsec configs')
    bg.add_argument('--binsec-timeout', action='store', metavar='<seconds>', type=int, default=30, help='timeout for binsec calls')
    bg.add_argument('--solver-timeout', action='store', metavar='<seconds>', type=int, default=15,
                    help='global timeout budget for abduction search (used with --collect-until-timeout)')
    bg.add_argument('--binsec-robust', action='store_true', help='use variable control from robustness')
    bg.add_argument('--robust-config', action='store', metavar='<robust.conf>', help='binsec robustness core configuration')
    bg.add_argument('--ct-mode', action='store_true', help='use BINSEC CHECKCT contract (secure/insecure/unknown)')
    bg.add_argument('--ct-unknown-retries', action='store', metavar='<int>', type=int, default=1,
                    help='number of extra retries when CHECKCT returns unknown')
    bg.add_argument('--ct-unknown-timeout-factor', action='store', metavar='<factor>', type=float, default=2.0,
                    help='multiplier applied to timeout on each unknown CHECKCT retry')
    bg.add_argument('--policy-report', action='store', metavar='<report.json>',
                    help='write policy selection/validation report as JSON')

    cg = ap.add_argument_group('Candidate generation options')
    cg.add_argument('--literals', action='store', metavar='<grammar>', help='candidates generation rules')
    cg.add_argument('--max-depth', action='store', metavar='<int>', type=int, help='max number of conjunctive literals')
    cg.add_argument('--sat-via-smt', action='store_true', help='use external smt solver to check consistency satisfaction')
    cg.add_argument('--consequence-checks-mode', action='store', metavar='<mode>', choices=ConsequenceCheckModes, default=ConsequenceCheckModes[0],
                    help='algorithmic mode to use for checking logical consequence status between candidates (available modes: {})'.format(', '.join(ConsequenceCheckModes)))
    cg.add_argument('--vexamples-init-count', action='store', metavar='<int>', type=int, default=0, help='number of initial vulnerability examples to recover')
    cg.add_argument('--no-constant-detection', action='store_false', dest='const_detect', help='do not predetect necessary constant equalities')
    cg.add_argument('--no-core-literals', action='store_false', dest='core_literals', help='do not add literals that do not contain any separated variable')
    cg.add_argument('--separate-bytes', action='store_true', help='separate variables in bytes')
    cg.add_argument('--separate-bits', action='store_true', help='separate variables in bits')
    cg.add_argument('--with-inequalities', action='store_true', help='use lt operator in litgen')
    cg.add_argument('--without-disequalities', action='store_false', dest='with_disequalities', help='do not use distinct operator in litgen')
    cg.add_argument('--with-auto-constants', action='store_true', help='add default basic constants 0, 1 to varset')
    cg.add_argument('--no-variables-binop', action='store_true', help='never apply binary operators to variable pairs')
    cg.add_argument('--input-variables-only', action='store_true', help='only use the user-given input variables')
    cg.add_argument('--no-literal-ordering', action='store_false', dest='lit_ordering', help='do not reorder literals via heuristic')
    cg.add_argument('--no-prune-counterex', action='store_false', dest='prune_counterex', help='do not prune with counter-examples')
    cg.add_argument('--no-prune-necessary', action='store_false', dest='prune_necessary', help='do not prune with necessary constraints')
    cg.add_argument('--force-on-model-resorting', action='store_true', help='resort literals after each new found example model')
    cg.add_argument('--collect-until-timeout', action='store_true',
                    help='continue searching after first NAS and stop at --solver-timeout')
    cg.add_argument('--paper-mode', action='store_true',
                    help='repro profile: no early cutoff (disables --collect-until-timeout)')
    cg.add_argument('--selection-mode', action='store',
                    choices=('branch-first', 'size-complexity'),
                    default='branch-first',
                    help='policy ranking mode: branch-first or size-complexity')

    args = ap.parse_args()

    try:
        main(args)
    except Exception as e:
        raise e
        sys.exit(1)
    sys.exit(0)
# ----------------------------------------
